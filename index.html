<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canteen Menu Recommender</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb;
        }
        
        /* Toggle button active states with light green highlighting */
        .view-toggle-active {
            background-color: #ecfdf5 !important;
            color: #065f46 !important;
            border-color: #34d399 !important;
            box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.3) !important;
        }
        
        .view-toggle-inactive {
            background-color: transparent !important;
            color: #6b7280 !important;
            border-color: transparent !important;
        }
        
        .view-toggle-inactive:hover {
            background-color: #f8fafc !important;
            color: #374151 !important;
        }
        .highlight-dish {
            transform: scale(1.03);
            box-shadow: 0 10px 15px -3px rgba(16, 185, 129, 0.3), 0 4px 6px -2px rgba(16, 185, 129, 0.2);
            border-color: #10b981;
            background-color: #ecfdf5;
        }
        .error-message {
            text-align: center;
            padding: 2rem;
            background-color: #fff;
            border: 1px solid #fee2e2;
            color: #b91c1c;
            border-radius: 0.75rem;
        }
        .day-dish {
            border-top: 1px solid #e5e7eb;
            padding-top: 1rem;
            margin-top: 1rem;
        }
        .day-dish:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        details > summary {
            list-style: none;
        }
        details > summary::-webkit-details-marker {
            display: none;
        }
        details[open] summary .arrow-down {
            transform: rotate(180deg);
        }
        
        /* Auto-hide transitions */
        details {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        details:not([open]) {
            opacity: 0.8;
            transform: scale(0.98);
        }
        
        details[open] {
            opacity: 1;
            transform: scale(1);
        }
        
        details summary {
            transition: all 0.3s ease-in-out;
        }
        
        details summary:hover {
            background-color: rgba(59, 130, 246, 0.05);
            border-radius: 8px;
            padding: 4px;
            margin: -4px;
        }
        
        .auto-collapse {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Subtle pulse animation for the filter section when collapsed */
        @keyframes filterPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.3);
            }
            50% { 
                box-shadow: 0 0 0 8px rgba(16, 185, 129, 0.1);
            }
        }
        
        details:not([open]) summary {
            animation: filterPulse 3s ease-in-out infinite;
        }
        
        /* Rocket animations */
        .rocket-icon {
            transition: all 0.3s ease;
            transform-origin: center;
        }
        
        .rocket-icon:hover {
            transform: translateY(-2px) scale(1.1);
        }
        
        .rocket-icon.active {
            color: #ff6b6b !important;
            animation: rocketBoost 1s ease-in-out infinite alternate;
        }
        
        .rocket-icon.active:hover {
            transform: translateY(-3px) scale(1.15);
        }
        
        @keyframes rocketBoost {
            0% { transform: translateY(0) scale(1); }
            100% { transform: translateY(-1px) scale(1.05); }
        }
        
        /* Rocket icons and simple smoke */
        .rocket-icon {
            transition: all 0.3s ease;
            transform-origin: center;
            filter: grayscale(100%) opacity(0.5);
        }
        
        .rocket-icon:hover {
            transform: translateY(-2px) scale(1.1);
            filter: grayscale(80%) opacity(0.8);
        }
        
        .rocket-icon.active {
            filter: none !important;
            opacity: 1 !important;
            animation: rocketBoost 1s ease-in-out infinite alternate;
        }
        
        .rocket-icon.active:hover {
            transform: translateY(-3px) scale(1.15);
            filter: none !important;
        }
        
        /* Simple smoke effect - positioned below and to the left of rocket */
        .smoke-effect {
            position: relative;
            display: inline-block;
        }
        
        .smoke-effect::before {
            content: '☁️';
            position: absolute;
            top: 20px;
            left: -20px;
            font-size: 10px;
            opacity: 0;
            z-index: 20;
            pointer-events: none;
        }
        
        /* Only show smoke when rocket is active within same container */
        .rocket-favorite-btn:has(.rocket-icon.active) .smoke-effect::before {
            opacity: 1;
            animation: simpleSmoke 3s ease-in-out infinite;
        }
        
        /* Fallback for browsers that don't support :has() */
        .rocket-favorite-btn.active .smoke-effect::before {
            opacity: 1;
            animation: simpleSmoke 3s ease-in-out infinite;
        }
        
        @keyframes simpleSmoke {
            0% { 
                opacity: 0;
                transform: translateX(0) translateY(0) scale(0.5);
            }
            30% { 
                opacity: 0.8;
                transform: translateX(-10px) translateY(-5px) scale(1.2);
            }
            60% { 
                opacity: 0.5;
                transform: translateX(-20px) translateY(-10px) scale(1.5);
            }
            100% { 
                opacity: 0;
                transform: translateX(-35px) translateY(-15px) scale(2);
            }
        }
        
        /* Rocket Flying Animation */
        .rocket-flying {
            position: fixed !important;
            z-index: 1000 !important;
            pointer-events: none;
            font-size: inherit !important; /* Maintain original size */
            transition: transform 0.063s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important; /* Bézier curves: 30 waypoints in 2 seconds */
            animation: rocketGlow 3.45s ease-in-out infinite alternate; /* 15% slower glow */
        }
        
        @keyframes rocketGlow {
            0%, 100% { 
                filter: brightness(1) drop-shadow(0 0 5px rgba(255, 107, 107, 0.5));
            }
            100% { 
                filter: brightness(1.3) drop-shadow(0 0 15px rgba(255, 107, 107, 0.9));
            }
        }
        
        /* Hide original rocket while flying */
        .rocket-favorite-btn.rocket-is-flying .rocket-icon {
            opacity: 0;
        }
    </style>
</head>
<body class="bg-gray-50">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">

        <!-- Header -->
        <header class="flex flex-col sm:flex-row items-center justify-between pb-6 border-b-2 border-gray-100 mb-8 gap-4">
            <div class="flex items-center gap-4">
                <img src="https://images.unsplash.com/photo-1546069901-ba9599a7e63c?q=80&w=800&auto=format&fit=crop" alt="A bowl of healthy food" class="h-12 w-12 rounded-full object-cover cursor-pointer hover:opacity-80 transition-opacity" onclick="toggleDebugMode()" title="Click to toggle debug view">
                <div>
                    <h1 class="text-2xl font-bold text-gray-800">Canteen Menu</h1>
                    <p class="text-gray-500">Your Weekly Dining Recommendations</p>
                </div>
            </div>
            <div class="flex flex-col items-end gap-2">
                <!-- View Toggle -->
                <div class="bg-gray-100 rounded-lg p-1 flex">
                    <button id="day-view-btn" class="px-3 py-1 rounded-md text-sm font-medium text-gray-700 bg-white shadow-sm transition-all duration-200 border border-gray-200" title="Show only today's menu">
                        Dag
                    </button>
                    <button id="week-view-btn" class="px-3 py-1 rounded-md text-sm font-medium text-gray-500 hover:text-gray-700 transition-all duration-200" title="Show full week">
                        Uge
                    </button>
                </div>
                <span class="text-sm text-gray-500">Uge <span id="current-week-number">-</span></span>
            </div>
        </header>

        <!-- Main controls -->
        <section id="controls-section" class="bg-white p-6 rounded-xl shadow-md mb-8">
            <details open>
                <summary class="flex justify-between items-center cursor-pointer">
                    <h2 class="text-lg font-bold text-gray-800">Filter Preferences</h2>
                    <svg class="w-6 h-6 text-gray-500 transition-transform arrow-down" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                    </svg>
                </summary>
                <div class="mt-4 border-t pt-4">
                    <p class="text-gray-500 mb-4">Select, add, or remove keywords for your recommendations. The system uses semantic matching to understand related terms (e.g., "høne" matches "kylling"). Changes are saved automatically.</p>
                    <div id="keywords-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-x-4 gap-y-3">
                        <!-- Checkboxes will be dynamically inserted here -->
                    </div>
                    <div class="flex items-center gap-2 mt-6 border-t pt-4">
                        <input type="text" id="new-keyword-input" placeholder="Add new preference..." class="flex-grow w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                        <button id="add-keyword-btn" class="bg-emerald-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-600">Add</button>
                    </div>
                </div>
            </details>
        </section>

        <div class="text-center mb-8">
             <button id="process-btn" class="w-full sm:w-auto bg-emerald-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-emerald-700 transition-colors shadow-sm disabled:bg-gray-400 disabled:cursor-not-allowed">
                Get Menu & Recommendations
            </button>
            <p id="api-limit-text" class="text-sm text-gray-500 mt-2"></p>
        </div>

        <!-- Menu Grid -->
        <main id="menu-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 hidden">
            <!-- Menu columns will be dynamically inserted here -->
        </main>

        <!-- Loading Spinner -->
        <div id="loading-spinner" class="hidden justify-center items-center h-64">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-emerald-500"></div>
            <p id="loading-text" class="ml-4 text-gray-600">Asking Gemini to read the website...</p>
        </div>
        
        <!-- Error Message Container -->
        <div id="error-container" class="hidden"></div>

    </div>

    <!-- Suggestion Modal -->
    <div id="suggestion-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
        <div class="relative top-20 mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <div class="flex justify-between items-center pb-3 border-b">
                    <h3 class="text-lg leading-6 font-medium text-gray-900">No Matches Found</h3>
                    <button id="close-modal-btn" class="text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm p-1.5 ml-auto inline-flex items-center">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                    </button>
                </div>
                <div class="mt-4">
                    <p class="text-sm text-gray-500 px-4">We couldn't find any matches for some days based on your current preferences. We've analyzed the menus for those days and suggest adding the following keywords to improve your recommendations.</p>
                    <div id="suggestions-container" class="my-4 px-4 text-left grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
                        <!-- Keyword suggestions will be dynamically inserted here -->
                    </div>
                </div>
                <div class="items-center px-4 py-3 border-t">
                    <button id="add-suggestions-btn" class="px-4 py-2 bg-emerald-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-300">
                        Add Selected Preferences
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const menuContainer = document.getElementById('menu-container');
            const loadingSpinner = document.getElementById('loading-spinner');
            const errorContainer = document.getElementById('error-container');
            const processBtn = document.getElementById('process-btn');
            const keywordsContainer = document.getElementById('keywords-container');
            const addKeywordBtn = document.getElementById('add-keyword-btn');
            const newKeywordInput = document.getElementById('new-keyword-input');
            const apiLimitText = document.getElementById('api-limit-text');
            const loadingText = document.getElementById('loading-text');
            const suggestionModal = document.getElementById('suggestion-modal');
            const suggestionsContainer = document.getElementById('suggestions-container');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const addSuggestionsBtn = document.getElementById('add-suggestions-btn');
            const filterDetails = document.querySelector('details'); // Filter preferences details element
            const dayViewBtn = document.getElementById('day-view-btn');
            const weekViewBtn = document.getElementById('week-view-btn');
            const currentWeekNumberSpan = document.getElementById('current-week-number');

            // --- State ---
            // IMPORTANT: The app credential is obfuscated to deter casual snooping.
            // For production environments, it is strongly recommended to use a backend proxy
            // to handle API calls and keep secrets secure.
            const encodedData = "QUl6YVN5Q2F0cmlBNFNBSVlvNEp0emxZcTgyZ0lYMmhuZ0Rnd2tB";
            
            // Robust decoding with error handling and validation
            let appToken;
            try {
                // Clean the encoded string (remove any trailing spaces/newlines)
                const cleanEncodedData = encodedData.trim();
                console.log('🔧 Raw encoded data:', cleanEncodedData);
                console.log('📏 Encoded length:', cleanEncodedData.length);
                
                // Check if it's valid base64
                if (!/^[A-Za-z0-9+/]*={0,2}$/.test(cleanEncodedData)) {
                    throw new Error('Invalid base64 characters detected');
                }
                
                // Decode using atob
                appToken = atob(cleanEncodedData);
                
                // Validate the decoded result
                if (!appToken || appToken.length < 20) {
                    throw new Error('Decoded key too short or empty');
                }
                
                // Check if it starts with expected Google API key format
                if (!appToken.startsWith('AIza')) {
                    console.warn('⚠️ Decoded key does not start with "AIza" as expected');
                }
                
                console.log('✅ Decoded API Key:', appToken.substring(0, 10) + '...' + appToken.substring(appToken.length - 10));
                console.log('📏 Decoded Length:', appToken.length);
                console.log('🔤 First 4 chars:', appToken.substring(0, 4));
                console.log('🔤 Last 4 chars:', appToken.substring(appToken.length - 4));
                console.log('🆕 Using NEW API Key (updated)');
                
            } catch (error) {
                console.error('❌ Error decoding API key:', error.message);
                console.error('🔧 Raw encoded data:', encodedData);
                // Fallback - try manual character inspection
                console.log('🔍 Manual inspection of encoded string:');
                for (let i = 0; i < Math.min(encodedData.length, 50); i++) {
                    console.log(`Char ${i}: "${encodedData[i]}" (ASCII: ${encodedData.charCodeAt(i)})`);
                }
                throw new Error('Failed to decode API key: ' + error.message);
            }
            const API_CALL_LIMIT = 4;
            const defaultKeywords = ['fjerkræ', 'flæskesteg', 'thai', 'indisk', 'karry', 'curry', 'bolognese', 'moussaka', 'gyudon', 'bao', 'spidsbryst', 'okse', 'fisk'];
            let keywords = [];
            let favorites = []; // In-memory favorites cache
            let parsedMenuData = null; // In-memory cache for the session
            let currentViewMode = 'day'; // Default to day view (phone-style)
            let currentRecommendations = null; // Store recommendations for re-rendering
            let isDebugMode = false; // Debug mode toggle state
            
            // Auto-hide functionality
            let collapseTimeout = null;
            
            // --- Debug Mode Functions ---
            window.toggleDebugMode = function() {
                isDebugMode = !isDebugMode;
                
                if (isDebugMode) {
                    showDebugView();
                } else {
                    showMainView();
                }
            }
            
            function showDebugView() {
                // Hide main content
                const mainContent = document.querySelector('.container');
                if (mainContent) {
                    mainContent.style.display = 'none';
                }
                
                // Create debug view
                const debugView = document.createElement('div');
                debugView.id = 'debug-view';
                debugView.className = 'min-h-screen bg-gray-50';
                debugView.innerHTML = `
                    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
                        <header class="flex items-center justify-between pb-6 border-b-2 border-gray-100 mb-8">
                            <div class="flex items-center gap-4">
                                <img src="https://images.unsplash.com/photo-1546069901-ba9599a7e63c?q=80&w=800&auto=format&fit=crop" alt="A bowl of healthy food" class="h-12 w-12 rounded-full object-cover cursor-pointer hover:opacity-80 transition-opacity" onclick="toggleDebugMode()">
                                <div>
                                    <h1 class="text-2xl font-bold text-gray-800">Debug Menu Viewer</h1>
                                    <p class="text-gray-500">Raw menu data from database</p>
                                </div>
                            </div>
                            <button onclick="toggleDebugMode()" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">
                                Back to App
                            </button>
                        </header>
                        
                        <div id="debug-content" class="bg-white rounded-xl shadow-md p-6">
                            <div class="text-center py-8">
                                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto"></div>
                                <p class="mt-2 text-gray-600">Loading menu data...</p>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(debugView);
                loadDebugMenuData();
            }
            
            function showMainView() {
                // Remove debug view
                const debugView = document.getElementById('debug-view');
                if (debugView) {
                    debugView.remove();
                }
                
                // Show main content
                const mainContent = document.querySelector('.container');
                if (mainContent) {
                    mainContent.style.display = 'block';
                }
            }
            
            async function loadDebugMenuData() {
                try {
                    const menuDB = new SharedMenuDatabase();
                    
                    const currentWeek = await menuDB.getCurrentWeekNumber();
                    const allMenus = await menuDB.getAllMenus();
                    
                    const debugContent = document.getElementById('debug-content');
                    
                    if (allMenus.length === 0) {
                        debugContent.innerHTML = `
                            <div class="text-center py-8">
                                <div class="text-gray-400 mb-4">
                                    <svg class="w-16 h-16 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2M4 13h2m13-8l-4 4m0 0l-4-4m4 4V3"></path>
                                    </svg>
                                </div>
                                <h3 class="text-lg font-medium text-gray-900 mb-2">No Shared Menu Data Found</h3>
                                <p class="text-gray-600">No menu data has been shared yet. The first person to visit and click "Get Menu & Recommendations" will populate the shared database.</p>
                            </div>
                        `;
                        return;
                    }
                    
                    debugContent.innerHTML = `
                        <div class="space-y-6">
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                <h2 class="text-lg font-semibold text-blue-900 mb-2">Shared Database Status</h2>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                                    <div>
                                        <span class="font-medium text-blue-800">Current Week:</span>
                                        <span class="text-blue-700">${currentWeek}</span>
                                    </div>
                                    <div>
                                        <span class="font-medium text-blue-800">Shared Menus:</span>
                                        <span class="text-blue-700">${allMenus.length}</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="space-y-4">
                                <h2 class="text-lg font-semibold text-gray-800">🌐 Shared Menu Data</h2>
                                ${allMenus.map(menu => `
                                    <div class="border border-gray-200 rounded-lg p-4 ${menu.week === currentWeek ? 'bg-green-50 border-green-200' : ''}">
                                        <div class="flex justify-between items-start mb-3">
                                            <div>
                                                <h3 class="font-semibold text-gray-800">
                                                    Week ${menu.week} ${menu.week === currentWeek ? '(Current)' : ''}
                                                </h3>
                                                <p class="text-sm text-gray-600">Saved: ${new Date(menu.timestamp).toLocaleString()}</p>
                                            </div>
                                            <button onclick="toggleMenuData(${menu.week})" class="px-3 py-1 bg-gray-100 text-gray-700 rounded text-sm hover:bg-gray-200">
                                                <span id="toggle-text-${menu.week}">Show Data</span>
                                            </button>
                                        </div>
                                        <div id="menu-data-${menu.week}" class="hidden">
                                            <div class="bg-gray-50 rounded p-4">
                                                <h4 class="font-medium text-gray-700 mb-2">Raw Menu Data:</h4>
                                                <pre class="text-xs text-gray-600 overflow-auto max-h-96 bg-white p-3 rounded border">${JSON.stringify(menu.menu, null, 2)}</pre>
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    
                } catch (error) {
                    console.error('Error loading debug menu data:', error);
                    document.getElementById('debug-content').innerHTML = `
                        <div class="text-center py-8">
                            <div class="text-red-400 mb-4">
                                <svg class="w-16 h-16 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                            </div>
                            <h3 class="text-lg font-medium text-gray-900 mb-2">Error Loading Menu Data</h3>
                            <p class="text-gray-600">${error.message}</p>
                        </div>
                    `;
                }
            }
            
            async function fetchSharedMenuData() {
                try {
                    const response = await fetch('https://raw.githubusercontent.com/typond/kantine-app/main/shared-menu.json?t=' + Date.now());
                    if (!response.ok) {
                        console.log('⚠️ Shared menu not available:', response.status);
                        return null;
                    }
                    return await response.json();
                } catch (error) {
                    console.log('⚠️ Error fetching shared menu:', error.message);
                    return null;
                }
            }
            
            window.toggleSharedMenuData = function() {
                const dataDiv = document.getElementById('shared-menu-data');
                const toggleText = document.getElementById('toggle-shared-text');
                
                if (dataDiv.classList.contains('hidden')) {
                    dataDiv.classList.remove('hidden');
                    toggleText.textContent = 'Hide Data';
                } else {
                    dataDiv.classList.add('hidden');
                    toggleText.textContent = 'Show Data';
                }
            }
            
            window.toggleMenuData = function(weekNumber) {
                const dataDiv = document.getElementById(`menu-data-${weekNumber}`);
                const toggleText = document.getElementById(`toggle-text-${weekNumber}`);
                
                if (dataDiv.classList.contains('hidden')) {
                    dataDiv.classList.remove('hidden');
                    toggleText.textContent = 'Hide Data';
                } else {
                    dataDiv.classList.add('hidden');
                    toggleText.textContent = 'Show Data';
                }
            }
            
            function autoCollapseFilters() {
                if (filterDetails) {
                    // Clear any existing timeout
                    if (collapseTimeout) {
                        clearTimeout(collapseTimeout);
                    }
                    
                    // Set new collapse timeout
                    collapseTimeout = setTimeout(() => {
                        if (filterDetails.open) {
                            filterDetails.classList.add('auto-collapse');
                            filterDetails.open = false;
                            
                            // Remove the class after animation completes
                            setTimeout(() => {
                                filterDetails.classList.remove('auto-collapse');
                            }, 400);
                        }
                    }, 1500); // Collapse after 1.5 second delay
                }
            }
            
            function autoExpandFilters() {
                if (filterDetails) {
                    // Clear any pending collapse
                    if (collapseTimeout) {
                        clearTimeout(collapseTimeout);
                        collapseTimeout = null;
                    }
                    
                    if (!filterDetails.open) {
                        filterDetails.classList.add('auto-collapse');
                        filterDetails.open = true;
                        
                        // Remove the class after animation completes
                        setTimeout(() => {
                            filterDetails.classList.remove('auto-collapse');
                        }, 400);
                    }
                }
            
            }
            
            function addAutoHideListeners() {
                // Listen for keyword interactions to auto-expand
                if (keywordsContainer) {
                    keywordsContainer.addEventListener('click', () => {
                        autoExpandFilters();
                    });
                }
                
                if (newKeywordInput) {
                    newKeywordInput.addEventListener('focus', () => {
                        autoExpandFilters();
                    });
                    
                    newKeywordInput.addEventListener('input', () => {
                        autoExpandFilters();
                    });
                    
                    newKeywordInput.addEventListener('keydown', () => {
                        autoExpandFilters();
                    });
                }
                
                if (addKeywordBtn) {
                    addKeywordBtn.addEventListener('click', () => {
                        autoExpandFilters();
                    });
                }
                
                // Auto-expand when suggestion modal is shown
                window.addEventListener('suggestionModalShown', () => {
                    autoExpandFilters();
                });
                
                // Auto-expand when there are empty preferences
                if (keywords.length === 0) {
                    autoExpandFilters();
                }
            }

            // --- Cookie & Cache Functions ---
            function saveCookie(name, value, days) {
                const d = new Date();
                d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
                let expires = "expires="+ d.toUTCString();
                document.cookie = name + "=" + JSON.stringify(value) + ";" + expires + ";path=/;SameSite=Lax";
            }

            function loadCookie(name) {
                let cookieName = name + "=";
                let decodedCookie = decodeURIComponent(document.cookie);
                let ca = decodedCookie.split(';');
                for(let i = 0; i <ca.length; i++) {
                    let c = ca[i];
                    while (c.charAt(0) === ' ') c = c.substring(1);
                    if (c.indexOf(cookieName) === 0) {
                        try {
                            return JSON.parse(c.substring(cookieName.length, c.length));
                        } catch (e) {
                            return null;
                        }
                    }
                }
                return null;
            }

            function getApiCount() {
                const today = new Date().toISOString().split('T')[0];
                const apiCountData = loadCookie('canteen_api_count');
                if (apiCountData && apiCountData.date === today) return apiCountData.count;
                return 0;
            }

            function incrementApiCount() {
                const today = new Date().toISOString().split('T')[0];
                let count = getApiCount();
                count++;
                saveCookie('canteen_api_count', { date: today, count: count }, 1);
                updateApiLimitText();
            }
            
            function updateApiLimitText() {
                const count = getApiCount();
                const remaining = API_CALL_LIMIT - count;
                apiLimitText.textContent = `You have ${remaining} recommendations left today.`;
                if (remaining <= 0) {
                    processBtn.disabled = true;
                    apiLimitText.textContent = "You have reached your daily limit for recommendations.";
                } else {
                    processBtn.disabled = false;
                }
            }

            function saveMenuToCache(menuData) {
                const today = new Date().toISOString().split('T')[0];
                const cacheData = { date: today, menu: menuData };
                localStorage.setItem('canteen_menu_cache', JSON.stringify(cacheData));
            }

            function loadMenuFromCache() {
                const today = new Date().toISOString().split('T')[0];
                const cachedData = localStorage.getItem('canteen_menu_cache');
                if (cachedData) {
                    try {
                        const parsed = JSON.parse(cachedData);
                        if (parsed.date === today) {
                            return parsed.menu;
                        }
                    } catch (e) {
                        return null;
                    }
                }
                return null;
            }

            function renderKeywords() {
                keywordsContainer.innerHTML = keywords.map(keyword => {
                    const isFav = favorites.includes(keyword);
                    return `<label class="flex items-center justify-between space-x-2 p-2 rounded-lg hover:bg-gray-50 cursor-pointer border border-transparent"><div class="flex items-center space-x-2"><input type="checkbox" value="${keyword}" class="keyword-checkbox h-4 w-4 rounded border-gray-300 text-emerald-600 focus:ring-emerald-500" checked><span class="text-gray-700 capitalize">${keyword}</span></div><div class="flex items-center space-x-2"><div class="relative"><button class="rocket-favorite-btn relative ${isFav ? 'active' : ''}" data-keyword="${keyword}" title="Launch as favorite"><span class="rocket-icon text-2xl ${isFav ? 'active' : ''}">🚀</span><div class="smoke-effect"></div></button></div><button class="delete-keyword-btn text-gray-400 hover:text-red-500" data-keyword="${keyword}" title="Delete keyword"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /></svg></button></div></label>`;
                }).join('');
            }

            // --- Shared Menu Database ---
            class SharedMenuDatabase {
                constructor() {
                    this.sharedMenuUrl = 'https://raw.githubusercontent.com/typond/kantine-app/main/shared-menu.json';
                }
                
                async getCurrentWeekNumber() {
                    const now = new Date();
                    const startOfYear = new Date(now.getFullYear(), 0, 1);
                    const pastDaysOfYear = (now.getTime() - startOfYear.getTime()) / 86400000;
                    return Math.ceil((pastDaysOfYear + startOfYear.getDay() + 1) / 7);
                }
                
                async getMenu(weekNumber) {
                    try {
                        console.log('🔍 Checking shared menu data for week', weekNumber);
                        const response = await fetch(this.sharedMenuUrl + '?t=' + Date.now()); // Cache bust
                        if (!response.ok) {
                            console.log('⚠️ Shared menu not available:', response.status);
                            return null;
                        }
                        
                        const sharedData = await response.json();
                        if (sharedData.menus && sharedData.menus[weekNumber]) {
                            console.log('✅ Found shared menu for week', weekNumber);
                            return sharedData.menus[weekNumber].menu;
                        }
                        
                        console.log('⚠️ No shared menu found for week', weekNumber);
                        return null;
                    } catch (error) {
                        console.log('⚠️ Error fetching shared menu:', error.message);
                        return null;
                    }
                }
                
                async saveMenu(weekNumber, menuData) {
                    try {
                        console.log('💾 Saving menu to shared storage for week', weekNumber);
                        
                        // For now, we'll use a simple approach: save to localStorage as a backup
                        // and show instructions for manual update to shared storage
                        const menuRecord = {
                            week: weekNumber,
                            menu: menuData,
                            timestamp: new Date().toISOString()
                        };
                        
                        // Save to localStorage as backup
                        localStorage.setItem(`menu_week_${weekNumber}`, JSON.stringify(menuRecord));
                        
                        // Show instructions for updating shared storage
                        console.log('📝 Menu saved locally. To update shared storage:');
                        console.log('1. Go to the GitHub repository');
                        console.log('2. Edit shared-menu.json');
                        console.log('3. Add the menu data for week', weekNumber);
                        
                        // For now, return true to indicate "saved" (locally)
                        return true;
                    } catch (error) {
                        console.error('Error saving menu:', error);
                        return false;
                    }
                }
                
                async getAllMenus() {
                    try {
                        const response = await fetch(this.sharedMenuUrl + '?t=' + Date.now());
                        if (!response.ok) {
                            return [];
                        }
                        
                        const sharedData = await response.json();
                        if (sharedData.menus) {
                            return Object.keys(sharedData.menus).map(week => ({
                                week: parseInt(week),
                                menu: sharedData.menus[week].menu,
                                timestamp: sharedData.menus[week].timestamp
                            })).sort((a, b) => b.week - a.week);
                        }
                        
                        return [];
                    } catch (error) {
                        console.error('Error retrieving all menus:', error);
                        return [];
                    }
                }
                
                async clearOldMenus(keepWeeks = 4) {
                    // This would need to be implemented in the shared storage system
                    console.log('🗑️ Clear old menus functionality would need to be implemented in shared storage');
                }
            }
            
            // Initialize the shared database
            const menuDB = new SharedMenuDatabase();
            
            // Debug: Monitor all network requests to identify the Google Apps Script call
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                const url = args[0];
                console.log('🌐 Network request intercepted:', url);
                if (typeof url === 'string' && url.includes('script.google.com')) {
                    console.error('🚨 Google Apps Script call detected:', url);
                    console.trace('Call stack:');
                }
                return originalFetch.apply(this, args);
            };
            
            // Shared database is ready to use immediately
            console.log('✅ Shared database ready');
            
            // Add database management functions
            async function showDatabaseStatus() {
                try {
                    const allMenus = await menuDB.getAllMenus();
                    const currentWeek = await menuDB.getCurrentWeekNumber();
                    
                    console.log('📊 Database Status:');
                    console.log('   Current Week:', currentWeek);
                    console.log('   Stored Menus:', allMenus.length);
                    console.log('   Available Weeks:', allMenus.map(m => `Week ${m.week} (${m.timestamp.split('T')[0]})`).join(', '));
                    
                    if (allMenus.length > 0) {
                        console.log('   Latest Menu:', `Week ${allMenus[0].week} from ${allMenus[0].timestamp}`);
                    }
                } catch (error) {
                    console.error('Error getting database status:', error);
                }
            }
            
            // Show database status on load
            showDatabaseStatus();

            // --- Gemini API Functions ---
            async function callGemini(prompt, apiKey) {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${apiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                
                let retries = 2; // Reduced from 3 to 2 for faster failure detection
                let delay = 1000; // Start with 1 second delay
                const timeout = 30000; // Reduced from 60s to 30s since prompts are optimized
                
                // Validate API key and payload before making the request
                console.log('🔍 API Call Validation:');
                console.log('   - API Key format:', apiKey.startsWith('AIza') ? '✅ Valid' : '❌ Invalid');
                console.log('   - Prompt length:', prompt.length, 'characters');
                console.log('   - Payload keys:', Object.keys(payload));
                console.log('   - Contents length:', payload.contents.length);
                console.log('   - Parts length:', payload.contents[0]?.parts.length);
                console.log('⏱️ Timeout set to:', timeout / 1000, 'seconds (optimized)');

                while (retries > 0) {
                    try {
                        // Create an AbortController for timeout
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), timeout);

                        try {
                            const response = await fetch(apiUrl, { 
                                method: 'POST', 
                                headers: { 'Content-Type': 'application/json' }, 
                                body: JSON.stringify(payload),
                                signal: controller.signal
                            });

                            clearTimeout(timeoutId);

                            // If the server is overloaded (503), throw an error to trigger a retry.
                            if (response.status === 503) {
                                throw new Error(`Model is overloaded. Retrying... (Attempt ${3-retries}/${3})`);
                            }

                            if (!response.ok) {
                                const errorBody = await response.text();
                                console.error("🚫 API Error Response:", errorBody);
                                console.error("🚫 Response Status:", response.status, response.statusText);
                                console.error("🚫 Request URL:", apiUrl.substring(0, 100) + "...");
                                console.error("🚫 API Key (first 10 chars):", apiKey.substring(0, 10) + "...");
                                console.error("🚫 API Key length:", apiKey.length);
                                console.error("🚫 API Key format check:", apiKey.startsWith('AIza') ? '✅ Valid format' : '❌ Invalid format');
                                
                                // For 400 errors, show more details about the API call
                                if (response.status === 400) {
                                    console.error("🔍 400 Bad Request Details:");
                                    console.error("   - Check if API key is valid and active");
                                    console.error("   - Check if model name is correct");
                                    console.error("   - Check API quota and billing");
                                    console.error("   - Check request payload format");
                                }
                                
                                throw new Error(`API request failed with status ${response.status}: ${errorBody}`);
                            }
                            
                            const result = await response.json();
                            if (result.candidates?.[0]?.content?.parts?.[0]) {
                                let jsonString = result.candidates[0].content.parts[0].text;
                                jsonString = jsonString.replace(/```json\n/g, '').replace(/```/g, '');
                                return JSON.parse(jsonString); // Success, exit the loop
                            } else {
                                throw new Error("Invalid response structure from Gemini API.");
                            }
                        } catch (fetchError) {
                            clearTimeout(timeoutId);
                            if (fetchError.name === 'AbortError') {
                                throw new Error('Request timeout - API took too long to respond.');
                            }
                            throw fetchError;
                        }
                    } catch (error) {
                        console.log(`Attempt failed: ${error.message}. Retries left: ${retries - 1}`);
                        
                        // Update loading text to show retry status
                        const loadingText = document.getElementById('loading-text');
                        if (loadingText && error.message.includes('Model is overloaded')) {
                            loadingText.textContent = `API is busy, retrying in ${delay/1000} seconds... (Attempt ${3-retries}/${3})`;
                        }
                        
                        retries--;
                        if (retries === 0) {
                            console.error("Error calling Gemini API after multiple retries:", error);
                            displayError(error.message);
                            return null;
                        }
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                    }
                }
                return null; // Should not be reached if all retries fail and throw an error
            }

            async function parseMenuWithGemini(siteHtml, apiKey) {
                const prompt = `Extract weekly menu from Danish HTML. Be flexible with cafeteria names and sub-kitchens.

IMPORTANT RULES:
1. HUBNORDIC cafeterias: Look for "HUB 1", "HUB 2", "HUB 3" (or variations like "Hub 1", "hub1", "HUB1")
2. FOODCORE cafeteria: Look for "Foodcore", "Food Core", "FoodCore" with sub-kitchens:
   - "Globetrotter" (or "Globetrotter", "Global", "International")
   - "Homebound" (or "Homebound", "Home Bound", "Local", "Danish")
3. Days: "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag"
4. Include "Vegetar" dishes when present
5. Extract FULL dish descriptions, not just names

OUTPUT FORMAT:
{
  "HUB 1": {
    "Mandag": "Full dish description with ingredients",
    "Tirsdag": "Full dish description...",
    ...
  },
  "HUB 2": { ... },
  "HUB 3": { ... },
  "Foodcore": {
    "Mandag": {
      "Globetrotter": "International dish description",
      "Homebound": "Local/Danish dish description"
    },
    "Tirsdag": { ... },
    ...
  }
}

HTML CONTENT:
${siteHtml}`;
                
                console.log('🔍 Enhanced menu parsing prompt length:', prompt.length, 'characters');
                const result = await callGemini(prompt, apiKey);
                console.log('✅ Menu parsing result:', result);
                return result;
            }

            async function getRecommendationsFromGemini(menuData, activeKeywords, activeFavoriteKeywords, apiKey) {
                // Enhanced synonym map for better matching
                const synonymMap = `{
                    protein: {
                        fjerkræ: ["kylling", "høne", "hane", "kalkun", "chicken", "poultry"],
                        okse: ["okse", "oksekød", "bøf", "spidsbryst", "beef"],
                        svin: ["svin", "svinekød", "gris", "flæsk", "flæskesteg", "pork"],
                        lam: ["lam", "lammekød", "mutton"],
                        fisk: ["fisk", "laks", "torsk", "kuller", "ørred", "tun", "salmon", "cod", "fish"],
                        skaldyr: ["rejer", "muslinger", "blæksprutte", "kammusling", "krabbe", "squid", "shrimp", "shellfish"]
                    },
                    diet: {
                        vegetar: ["vegetar", "vegetarian"],
                        vegansk: ["vegansk", "vegan"]
                    },
                    cuisine: {
                        indisk: ["indisk", "indian", "masala", "tikka", "karry", "curry"],
                        thai: ["thai", "thailandsk", "green curry", "red curry", "pad thai"],
                        italiensk: ["italiensk", "italian", "pasta", "bolognese", "pizza", "lasagne"],
                        græsk: ["græsk", "greek", "moussaka", "souvlaki", "gyro"],
                        japansk: ["japansk", "japanese", "gyudon", "ramen", "sushi", "katsu"],
                        kinesisk: ["kinesisk", "chinese", "bao", "dumpling"],
                        mexicansk: ["mexicansk", "mexican", "taco", "burrito"],
                        burger: ["burger", "hamburger"],
                        salat: ["salat", "salad"]
                    }
                }`;
                
                const prompt = `You are a food recommendation system for Danish canteen menus. Analyze user preferences and recommend the best cafeteria for each day.

MATCHING RULES:
1. Direct keyword match: +3 points
2. Synonym/category match: +2 points  
3. Cuisine/style match: +1 point
4. Favorite preferences: +2 bonus points
5. If user has "vegetar"/"vegansk", exclude meat/fish unless marked vegetarian/vegan
6. CRITICAL: If all cafeteria scores <2 for a day, return "Any" for that day
7. For Foodcore: consider both Globetrotter and Homebound dishes, choose the cafeteria with best overall match
8. IMPORTANT: You MUST return "Any" for days where no cafeteria has a score ≥2

MENU DATA:
${JSON.stringify(menuData, null, 2)}

USER PREFERENCES: ${activeKeywords}
FAVORITE PREFERENCES: ${activeFavoriteKeywords}
SYNONYM MAP: ${synonymMap}

OUTPUT: Return JSON mapping each day to cafeteria name.
IMPORTANT: Use "Any" for days with no good matches (score <2).
Example: {"Mandag": "HUB 1", "Tirsdag": "Foodcore", "Onsdag": "Any", "Torsdag": "HUB 2", "Fredag": "Any"}

SCORING EXAMPLE:
- If HUB 1 scores 3, HUB 2 scores 1, Foodcore scores 0 → return "HUB 1"
- If HUB 1 scores 1, HUB 2 scores 1, Foodcore scores 1 → return "Any"
- If HUB 1 scores 0, HUB 2 scores 0, Foodcore scores 0 → return "Any"`;
                
                console.log('🔍 Enhanced recommendation prompt length:', prompt.length, 'characters');
                const result = await callGemini(prompt, apiKey);
                console.log('✅ Recommendation result:', result);
                console.log('🔍 Recommendation analysis:');
                console.log('   Result type:', typeof result);
                console.log('   Result keys:', Object.keys(result || {}));
                console.log('   Days with "Any":', Object.keys(result || {}).filter(day => result[day] === 'Any'));
                console.log('   Days with specific cafeterias:', Object.keys(result || {}).filter(day => result[day] !== 'Any'));
                return result;
            }


            async function getKeywordSuggestionsFromGemini(dishes, apiKey) {
                // Use enhanced synonym map for consistency
                const synonymMap = `{
                    protein: {
                        fjerkræ: ["kylling", "høne", "hane", "kalkun", "chicken", "poultry"],
                        okse: ["okse", "oksekød", "bøf", "spidsbryst", "beef"],
                        svin: ["svin", "svinekød", "gris", "flæsk", "flæskesteg", "pork"],
                        lam: ["lam", "lammekød", "mutton"],
                        fisk: ["fisk", "laks", "torsk", "kuller", "ørred", "tun", "salmon", "cod", "fish"],
                        skaldyr: ["rejer", "muslinger", "blæksprutte", "kammusling", "krabbe", "squid", "shrimp", "shellfish"]
                    },
                    diet: {
                        vegetar: ["vegetar", "vegetarian"],
                        vegansk: ["vegansk", "vegan"]
                    },
                    cuisine: {
                        indisk: ["indisk", "indian", "masala", "tikka", "karry", "curry"],
                        thai: ["thai", "thailandsk", "green curry", "red curry", "pad thai"],
                        italiensk: ["italiensk", "italian", "pasta", "bolognese", "pizza", "lasagne"],
                        græsk: ["græsk", "greek", "moussaka", "souvlaki", "gyro"],
                        japansk: ["japansk", "japanese", "gyudon", "ramen", "sushi", "katsu"],
                        kinesisk: ["kinesisk", "chinese", "bao", "dumpling"],
                        mexicansk: ["mexicansk", "mexican", "taco", "burrito"],
                        burger: ["burger", "hamburger"],
                        salat: ["salat", "salad"]
                    }
                }`;
                
                const prompt = `Extract 5-12 Danish food keywords from dishes. Use the synonym map to group similar terms and suggest canonical Danish keywords.

INSTRUCTIONS:
- Use protein categories: "fjerkræ", "okse", "svin", "lam", "fisk", "skaldyr"
- Use cuisine types: "indisk", "thai", "italiensk", "græsk", "japansk", "kinesisk", "mexicansk"
- Use diet types: "vegetar", "vegansk"
- Use general terms: "burger", "salat"
- Prefer Danish terms over English equivalents

DISHES: ${JSON.stringify(dishes)}
SYNONYM MAP: ${synonymMap}

OUTPUT: Return JSON array of Danish keywords.
Example: ["fjerkræ", "okse", "indisk", "vegetar", "salat"]`;
                
                const result = await callGemini(prompt, apiKey);
                // Ensure the result is an array and all items are strings.
                if (Array.isArray(result) && result.every(item => typeof item === 'string')) {
                    return result;
                }
                return []; // Return empty array on failure or wrong type
            }
            
            function displayError(message) {
                loadingSpinner.classList.add('hidden');
                
                let errorMessage = message;
                let errorDetails = '';
                
                // Add helpful context for common errors
                if (message.includes('Model is overloaded')) {
                    errorMessage = 'API Service Temporarily Unavailable';
                    errorDetails = 'The AI service is experiencing high demand. Please try again in a few minutes. Each device needs to parse the menu separately, so this is normal when using the app on multiple devices.';
                } else if (message.includes('timeout')) {
                    errorMessage = 'Request Timeout';
                    errorDetails = 'The request took too long to complete. This might be due to high API load. Please try again.';
                }
                
                errorContainer.innerHTML = `
                    <div class="error-message">
                        <h3 class="font-bold text-lg mb-2">${errorMessage}</h3>
                        <p class="mb-3">${message}</p>
                        ${errorDetails ? `<p class="text-sm text-gray-600">${errorDetails}</p>` : ''}
                    </div>
                `;
                errorContainer.classList.remove('hidden');
            }
            
            function getTodayName() {
                const today = new Date();
                const dayNames = ["Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag"];
                return dayNames[today.getDay()];
            }

            function generateCalendarLink(day, cafeteria, dish) {
                const dayMap = { "Mandag": 1, "Tirsdag": 2, "Onsdag": 3, "Torsdag": 4, "Fredag": 5 };
                const targetDay = dayMap[day];
                if (typeof targetDay === 'undefined') return '#';
                const now = new Date();
                const today = now.getDay();
                let dayDifference = targetDay - today;
                if (dayDifference < 0) dayDifference += 7;
                const eventDate = new Date();
                eventDate.setDate(now.getDate() + dayDifference);
                const startTime = new Date(eventDate.setHours(11, 30, 0, 0));
                const endTime = new Date(eventDate.setHours(12, 0, 0, 0));
                const formatDate = (date) => date.toISOString().replace(/-|:|\.\d{3}/g, '');
                const baseUrl = "https://www.google.com/calendar/render?action=TEMPLATE";
                const title = encodeURIComponent(`Frokost: ${cafeteria}`);
                const details = encodeURIComponent(`Dagens ret: ${dish}`);
                const location = encodeURIComponent("HUBNORDIC Kantine");
                const dates = `${formatDate(startTime)}/${formatDate(endTime)}`;
                return `${baseUrl}&text=${title}&dates=${dates}&details=${details}&location=${location}`;
            }

            /**
             * Animates a rocket flying around the screen with curved flight paths
             * @param {HTMLElement} rocketBtn - The rocket button element to animate
             * @param {Function} onComplete - Optional callback function to run before showing the rocket again
             */
            function animateRocket(rocketBtn, onComplete) {
                const rocket = rocketBtn.querySelector('.rocket-icon');
                if (!rocket) return;
                
                // Mark button as flying to hide original rocket
                rocketBtn.classList.add('rocket-is-flying');
                
                // Clone the rocket for flying animation with original font-size
                const flyingRocket = rocket.cloneNode(true);
                flyingRocket.className = 'rocket-flying';
                
                // Preserve original size by copying computed styles
                const computedStyle = window.getComputedStyle(rocket);
                flyingRocket.style.fontSize = computedStyle.fontSize;
                
                // Get original rocket position relative to viewport
                // Position at top-right corner of the icon
                const rect = rocket.getBoundingClientRect();
                flyingRocket.style.left = (rect.left + rect.width) + 'px'; // Right edge of icon
                flyingRocket.style.top = rect.top + 'px'; // Top edge of icon
                
                // Add flying rocket to body
                document.body.appendChild(flyingRocket);
                
                // Generate curved flight path adapted to rocket position (left flies right, right flies left)
                const flightPath = generateCurvedFlightPath(30, rocketBtn); // 30 waypoints along Bézier curves for ultra-smooth animation
                let currentPosition = 0;
                
                function moveToNextPosition() {
                    if (currentPosition < flightPath.length) {
                        const pos = flightPath[currentPosition];
                        // Use translate3d for better performance and smoother curves
                        flyingRocket.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0) rotate(${pos.rotation}deg)`;
                        currentPosition++;
                        setTimeout(moveToNextPosition, 63); // Bézier curves: 30 waypoints in 2 seconds
                    } else {
                        // Land back at original position with final curve
                        flyingRocket.style.transform = 'translate3d(0, 0, 0) rotate(0deg)';
                        setTimeout(() => {
                            if (document.body.contains(flyingRocket)) {
                                document.body.removeChild(flyingRocket);
                            }
                            // Run callback before showing rocket again (to apply active class first)
                            if (onComplete) {
                                onComplete();
                            }
                            
                            // Show sparkle effect briefly before revealing rocket
                            const rocketIcon = rocketBtn.querySelector('.rocket-icon');
                            if (rocketIcon) {
                                const originalContent = rocketIcon.textContent;
                                rocketIcon.textContent = '✨'; // Show sparkle
                                rocketBtn.classList.remove('rocket-is-flying'); // Make visible
                                
                                // After 280ms, restore original rocket icon
                                setTimeout(() => {
                                    rocketIcon.textContent = originalContent; // Restore rocket
                                }, 280);
                            } else {
                                // Fallback if no icon found
                                setTimeout(() => {
                                    rocketBtn.classList.remove('rocket-is-flying');
                                }, 50);
                            }
                        }, 63); // Bézier curve landing: 30 waypoints in 2 seconds
                    }
                }
                
                // Start animation sequence with slight delay (also 15% slower)
                setTimeout(moveToNextPosition, 50); // Fast start: optimized for 2-second animation
            }

            /**
             * Calculates a point on a cubic Bézier curve
             * @param {number} t - Parameter from 0 to 1
             * @param {Object} p0 - Start point {x, y}
             * @param {Object} p1 - First control point {x, y}
             * @param {Object} p2 - Second control point {x, y}
             * @param {Object} p3 - End point {x, y}
             * @returns {Object} Point on curve {x, y}
             */
            function cubicBezier(t, p0, p1, p2, p3) {
                const u = 1 - t;
                const tt = t * t;
                const uu = u * u;
                const uuu = uu * u;
                const ttt = tt * t;
                
                // Cubic Bézier formula: B(t) = (1-t)³P₀ + 3(1-t)²tP₁ + 3(1-t)t²P₂ + t³P₃
                const x = uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x;
                const y = uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y;
                
                return { x, y };
            }
            
            /**
             * Calculates the tangent (derivative) of a cubic Bézier curve at point t
             * Used to determine rocket rotation angle
             * @param {number} t - Parameter from 0 to 1
             * @param {Object} p0 - Start point {x, y}
             * @param {Object} p1 - First control point {x, y}
             * @param {Object} p2 - Second control point {x, y}
             * @param {Object} p3 - End point {x, y}
             * @returns {Object} Tangent vector {x, y}
             */
            function cubicBezierTangent(t, p0, p1, p2, p3) {
                const u = 1 - t;
                const uu = u * u;
                const tt = t * t;
                
                // Derivative: B'(t) = 3(1-t)²(P₁-P₀) + 6(1-t)t(P₂-P₁) + 3t²(P₃-P₂)
                const x = 3 * uu * (p1.x - p0.x) + 6 * u * t * (p2.x - p1.x) + 3 * tt * (p3.x - p2.x);
                const y = 3 * uu * (p1.y - p0.y) + 6 * u * t * (p2.y - p1.y) + 3 * tt * (p3.y - p2.y);
                
                return { x, y };
            }

            /**
             * Generates smooth Bézier curve flight path across the screen
             * Uses cubic Bézier curves for professional-grade smooth animations
             * Flight direction adapts based on rocket position (left flies right, right flies left)
             * @param {number} pointCount - Number of waypoints to generate along Bézier curves
             * @param {HTMLElement} rocketBtn - The rocket button to determine position
             * @returns {Array} Array of position objects with smooth Bézier trajectories
             */
            function generateCurvedFlightPath(pointCount, rocketBtn) {
                // Professional Bézier curve flight with sequential directional patterns
                // Get the window dimensions for unrestricted flight
                const boxWidth = window.innerWidth;
                const boxHeight = window.innerHeight;
                
                // Determine rocket's order in the sequence and direction
                const allRockets = document.querySelectorAll('.rocket-favorite-btn');
                const rocketIndex = Array.from(allRockets).indexOf(rocketBtn);
                const directionSequence = ['UP', 'DOWN', 'RIGHT', 'LEFT'];
                const flightDirection = directionSequence[rocketIndex % 4]; // Cycle through: UP → DOWN → RIGHT → LEFT
                
                // Determine if rocket is on left or right side of screen
                const rocketRect = rocketBtn.getBoundingClientRect();
                const rocketCenterX = rocketRect.left + rocketRect.width / 2;
                const screenCenterX = window.innerWidth / 2;
                const isLeftSide = rocketCenterX < screenCenterX;
                
                // Generate unique patterns using rocket position as seed for variation
                const positionHash = Math.abs(rocketCenterX.toString().split('').reduce((a,b) => a + b.charCodeAt(0), 0));
                const patternVariation = (positionHash % 5) / 5; // 0 to 0.8 variation
                const curveIntensity = 0.3 + patternVariation * 0.4; // 0.3 to 0.7 intensity
                
                // Define varied control points for cubic Bézier curves
                let curve1Start, curve1Control1, curve1Control2, curve1End;
                let curve2Start, curve2Control1, curve2Control2, curve2End;
                let curve3Start, curve3Control1, curve3Control2, curve3End;
                
                // Create flight patterns based on sequential direction
                const variant1 = patternVariation;
                const variant2 = (positionHash * 1.618) % 1; // Golden ratio for smooth variation
                const variant3 = (positionHash * 2.718) % 1; // Euler's number for different variation
                
                // Base curve starting point
                curve1Start = { x: 0, y: 0 };
                
                // Generate curves based on assigned flight direction
                if (flightDirection === 'UP') {
                    // UP: Start → Top area → Top corners → Return from bottom-left
                    
                    // Curve 1: Start → Upper area (UP flight path)
                    
                    // Curve 1: Start → Upper-right area (varied)
                    curve1Start = { x: 0, y: 0 };
                    curve1Control1 = { 
                        x: boxWidth * (0.1 + variant1 * 0.3), 
                        y: -boxHeight * (0.15 + variant2 * 0.2) 
                    };
                    curve1Control2 = { 
                        x: boxWidth * (0.3 + variant3 * 0.4), 
                        y: -boxHeight * (0.4 + variant1 * 0.3) 
                    };
                    curve1End = { 
                        x: boxWidth * (0.5 + variant2 * 0.3), 
                        y: -boxHeight * (0.6 + variant3 * 0.2) 
                    };
                    
                    // Curve 2: Upper-right → Right bottom corner (varied)
                    curve2Start = curve1End;
                    curve2Control1 = { 
                        x: boxWidth * (0.8 + variant2 * 0.1), 
                        y: boxHeight * (0.25 + variant3 * 0.2) 
                    };
                    curve2Control2 = { 
                        x: boxWidth * (0.6 + variant1 * 0.15), 
                        y: boxHeight * (0.7 + variant2 * 0.2) 
                    };
                    curve2End = { 
                        x: boxWidth * (0.85 + variant3 * 0.1), 
                        y: boxHeight * (0.6 + variant1 * 0.2) 
                    };
                    
                    // Curve 3: Right bottom corner → Origin (varied)
                    curve3Start = curve2End;
                    curve3Control1 = { 
                        x: boxWidth * (0.9 + variant2 * 0.1), 
                        y: boxHeight * (0.4 + variant1 * 0.15) 
                    };
                    curve3Control2 = { 
                        x: boxWidth * (0.95 + variant3 * 0.05), 
                        y: boxHeight * (0.15 + variant2 * 0.1) 
                    };
                    curve3End = { x: 0, y: 0 }; // Origin
                } else if (flightDirection === 'DOWN') {
                    // DOWN: Start → Bottom area → Bottom corners → Return from top-left
                    curve1Control1 = { 
                        x: boxWidth * (0.1 + variant1 * 0.3), 
                        y: boxHeight * (0.15 + variant2 * 0.2) 
                    };
                    curve1Control2 = { 
                        x: boxWidth * (0.3 + variant3 * 0.4), 
                        y: boxHeight * (0.4 + variant1 * 0.3) 
                    };
                    curve1End = { 
                        x: boxWidth * (0.5 + variant2 * 0.3), 
                        y: boxHeight * (0.6 + variant3 * 0.2) 
                    };
                    
                    curve2Start = curve1End;
                    curve2Control1 = { 
                        x: boxWidth * (0.7 + variant1 * 0.2), 
                        y: boxHeight * (0.4 + variant2 * 0.3) 
                    };
                    curve2Control2 = { 
                        x: boxWidth * (0.8 + variant3 * 0.15), 
                        y: boxHeight * (0.9 + variant1 * 0.08) 
                    };
                    curve2End = { 
                        x: boxWidth * (0.1 + variant2 * 0.1), 
                        y: boxHeight * (0.2 + variant3 * 0.15) 
                    };
                    
                    curve3Start = curve2End;
                    curve3Control1 = { 
                        x: boxWidth * (0.2 + variant1 * 0.2), 
                        y: -boxHeight * (0.1 + variant2 * 0.2) 
                    };
                    curve3Control2 = { 
                        x: boxWidth * (0.05 + variant3 * 0.1), 
                        y: boxHeight * (0.4 + variant1 * 0.2) 
                    };
                    curve3End = { x: 0, y: 0 }; // Origin
                    
                } else if (flightDirection === 'RIGHT') {
                    // RIGHT: Start → Right area → Right corners → Return from bottom-left
                    curve1Control1 = { 
                        x: boxWidth * (0.15 + variant1 * 0.3), 
                        y: boxHeight * (0.1 + variant2 * 0.2) 
                    };
                    curve1Control2 = { 
                        x: boxWidth * (0.4 + variant3 * 0.3), 
                        y: boxHeight * (0.3 + variant1 * 0.3) 
                    };
                    curve1End = { 
                        x: boxWidth * (0.6 + variant2 * 0.2), 
                        y: boxHeight * (0.5 + variant3 * 0.3) 
                    };
                    
                    curve2Start = curve1End;
                    curve2Control1 = { 
                        x: boxWidth * (0.8 + variant1 * 0.15), 
                        y: boxHeight * (0.7 + variant2 * 0.2) 
                    };
                    curve2Control2 = { 
                        x: boxWidth * (0.9 + variant3 * 0.08), 
                        y: boxHeight * (0.4 + variant1 * 0.3) 
                    };
                    curve2End = { 
                        x: boxWidth * (0.7 + variant2 * 0.2), 
                        y: boxHeight * (0.8 + variant3 * 0.15) 
                    };
                    
                    curve3Start = curve2End;
                    curve3Control1 = { 
                        x: boxWidth * (0.4 + variant1 * 0.3), 
                        y: boxHeight * (0.9 + variant2 * 0.08) 
                    };
                    curve3Control2 = { 
                        x: boxWidth * (0.1 + variant3 * 0.2), 
                        y: boxHeight * (0.6 + variant1 * 0.3) 
                    };
                    curve3End = { x: 0, y: 0 }; // Origin
                    
                } else if (flightDirection === 'LEFT') {
                    // LEFT: Start → Left area → Left corners → Return from bottom-right
                    curve1Control1 = { 
                        x: -boxWidth * (0.15 + variant1 * 0.3), 
                        y: boxHeight * (0.1 + variant2 * 0.2) 
                    };
                    curve1Control2 = { 
                        x: -boxWidth * (0.4 + variant3 * 0.3), 
                        y: boxHeight * (0.3 + variant1 * 0.3) 
                    };
                    curve1End = { 
                        x: -boxWidth * (0.6 + variant2 * 0.2), 
                        y: boxHeight * (0.5 + variant3 * 0.3) 
                    };
                    
                    curve2Start = curve1End;
                    curve2Control1 = { 
                        x: -boxWidth * (0.8 + variant1 * 0.15), 
                        y: boxHeight * (0.7 + variant2 * 0.2) 
                    };
                    curve2Control2 = { 
                        x: -boxWidth * (0.9 + variant3 * 0.08), 
                        y: boxHeight * (0.4 + variant1 * 0.3) 
                    };
                    curve2End = { 
                        x: -boxWidth * (0.7 + variant2 * 0.2), 
                        y: boxHeight * (0.8 + variant3 * 0.15) 
                    };
                    
                    curve3Start = curve2End;
                    curve3Control1 = { 
                        x: -boxWidth * (0.4 + variant1 * 0.3), 
                        y: boxHeight * (0.9 + variant2 * 0.08) 
                    };
                    curve3Control2 = { 
                        x: -boxWidth * (0.1 + variant3 * 0.2), 
                        y: boxHeight * (0.6 + variant1 * 0.3) 
                    };
                    curve3End = { x: 0, y: 0 }; // Origin
                }
                
                const path = [];
                const pointsPerCurve = Math.floor(pointCount / 3);
                
                // Generate points along Curve 1 (Start → Upper area)
                for (let i = 0; i <= pointsPerCurve; i++) {
                    const t = i / pointsPerCurve;
                    const point = cubicBezier(t, curve1Start, curve1Control1, curve1Control2, curve1End);
                    const tangent = cubicBezierTangent(t, curve1Start, curve1Control1, curve1Control2, curve1End);
                    // Rotation automatically calculated from curve tangent + 45° tilt to the right
                    const rotation = Math.atan2(tangent.y, tangent.x) * 180 / Math.PI + 45;
                    
                    path.push({
                        x: point.x,
                        y: point.y,
                        rotation: rotation
                    });
                }
                
                // Generate points along Curve 2 (Upper area → Left bottom corner)
                for (let i = 1; i <= pointsPerCurve; i++) {
                    const t = i / pointsPerCurve;
                    const point = cubicBezier(t, curve2Start, curve2Control1, curve2Control2, curve2End);
                    const tangent = cubicBezierTangent(t, curve2Start, curve2Control1, curve2Control2, curve2End);
                    const rotation = Math.atan2(tangent.y, tangent.x) * 180 / Math.PI + 45; // +45° tilt to the right
                    
                    path.push({
                        x: point.x,
                        y: point.y,
                        rotation: rotation
                    });
                }
                
                // Generate points along Curve 3 (Left bottom corner → Origin)
                for (let i = 1; i <= pointsPerCurve; i++) {
                    const t = i / pointsPerCurve;
                    const point = cubicBezier(t, curve3Start, curve3Control1, curve3Control2, curve3End);
                    const tangent = cubicBezierTangent(t, curve3Start, curve3Control1, curve3Control2, curve3End);
                    const rotation = Math.atan2(tangent.y, tangent.x) * 180 / Math.PI + 45; // +45° tilt to the right
                    
                    path.push({
                        x: point.x,
                        y: point.y,
                        rotation: rotation
                    });
                }
                
                return path;
            }

            /**
             * Applies quadratic bezier smoothing to create natural curved flight paths
             * @param {Array} points - Array of control points
             * @returns {Array} Smoothed path points
             */
            function smoothBezierPath(points) {
                if (points.length < 2) return points;
                
                const smoothed = [];
                
                for (let i = 0; i < points.length; i++) {
                    if (i === 0) {
                        // First point: linear towards next
                        smoothed.push({
                            x: points[i].x,
                            y: points[i].y,
                            rotation: points[i].rotation
                        });
                    } else if (i === points.length - 1) {
                        // Last point: linear from previous
                        smoothed.push({
                            x: points[i].x,
                            y: points[i].y,
                            rotation: points[i].rotation
                        });
                    } else {
                        // Middle points: quadratic bezier curve
                        const prevPoint = points[i - 1];
                        const currPoint = points[i];
                        const nextPoint = points[i + 1];
                        
                        // Control point calculation for smooth curves
                        const cp1x = prevPoint.x + (currPoint.x - prevPoint.x) * 0.5;
                        const cp1y = prevPoint.y + (currPoint.y - prevPoint.y) * 0.5;
                        const cp2x = currPoint.x + (nextPoint.x - currPoint.x) * 0.5;
                        const cp2y = currPoint.y + (nextPoint.y - currPoint.y) * 0.5;
                        
                        smoothed.push({
                            x: cp2x,
                            y: cp2y,
                            rotation: currPoint.rotation + (Math.sin(i) * 10) // Add subtle variation
                        });
                    }
                }
                
                return smoothed;
            }

            function renderMenu(menuData, recommendations) {
                loadingSpinner.classList.add('hidden');
                menuContainer.innerHTML = '';
                menuContainer.classList.remove('hidden');
                
                // Get current view mode (day by default, matches phone view)
                const isDayView = currentViewMode === 'day';
                
                if (isDayView) {
                    // Mobile view: Show only today's menus with recommended first
                    const todayName = getTodayName();
                    const todayDate = new Date();
                    const isWorkday = todayDate.getDay() >= 1 && todayDate.getDay() <= 5; // Monday-Friday
                    
                    // For weekends, show next Monday's menu
                    let targetDay = todayName;
                    if (!isWorkday) {
                        targetDay = "Mandag"; // Always show next Monday's menu on weekends
                    }
                    
                    const recommendedCafeteria = recommendations[targetDay];
                    
                    // Create array of cafeteria entries with recommended first
                    const cafeteriaEntries = [];
                    const cafeteriaOrder = ["HUB 1", "HUB 2", "HUB 3", "Foodcore"];
                    
                    for (const cafeteria of cafeteriaOrder) {
                        const cafeteriaMenu = menuData[cafeteria];
                        if (!cafeteriaMenu) continue;
                        
                        const dishEntry = cafeteriaMenu[targetDay];
                        if (!dishEntry) continue;
                        
                        const isRecommended = recommendedCafeteria === cafeteria;
                        
                        cafeteriaEntries.push({
                            cafeteria: cafeteria,
                            dishEntry: dishEntry,
                            isRecommended: recommendedCafeteria === cafeteria,
                            targetDay: targetDay,
                            isWeekendView: !isWorkday
                        });
                    }
                    
                    // Sort to put recommended first
                    cafeteriaEntries.sort((a, b) => {
                        if (a.isRecommended && !b.isRecommended) return -1;
                        if (!a.isRecommended && b.isRecommended) return 1;
                        return 0;
                    });
                    
                    // Create single column layout for day view (always phone-style)
                    menuContainer.className = 'grid grid-cols-1 gap-6';
                    
                    for (const entry of cafeteriaEntries) {
                        const column = document.createElement('div');
                        column.className = `bg-white rounded-xl shadow-md overflow-hidden flex flex-col ${entry.isRecommended ? 'md:order-first' : ''}`;
                        
                        let headerHtml = `<div class="p-4 bg-gray-100 border-b border-gray-200"><h2 class="text-xl font-bold text-center text-gray-700">${entry.cafeteria}</h2></div>`;
                        
                        let dishHtml = '';
                        let fullDishDescription = '';
                        if (typeof entry.dishEntry === 'string') {
                            dishHtml = `<p class="text-gray-600">${entry.dishEntry}</p>`;
                            fullDishDescription = entry.dishEntry;
                        } else {
                            dishHtml = '<div>';
                            let dishParts = [];
                            for (const subKitchen in entry.dishEntry) {
                                dishHtml += `<div class="mb-2 last:mb-0"><h4 class="font-medium text-gray-700">${subKitchen}</h4><p class="text-gray-600">${entry.dishEntry[subKitchen]}</p></div>`;
                                dishParts.push(`${subKitchen}: ${entry.dishEntry[subKitchen]}`);
                            }
                            dishHtml += '</div>';
                            fullDishDescription = dishParts.join(' / ');
                        }
                        
                        const calendarLink = generateCalendarLink(entry.targetDay, entry.cafeteria, fullDishDescription);
                        const cardClasses = `p-4 rounded-lg border-2 ${entry.isRecommended ? 'highlight-dish' : 'bg-white border-transparent'}`;
                        
                        const dayLabel = entry.isWeekendView ? `${entry.targetDay} (næste uge)` : entry.targetDay;
                        
                        const dailyDishesHtml = `<div class="p-5 flex-grow">
                            <div class="${cardClasses}">
                                <div class="flex justify-between items-center mb-2">
                                    <h3 class="font-semibold text-gray-800">${dayLabel}</h3>
                                    <div class="flex items-center space-x-2">
                                        ${entry.isRecommended ? '<span class="text-xs font-bold bg-emerald-500 text-white py-1 px-2 rounded-full shadow">EKSPERTENS VALG</span>' : ''}
                                        <a href="${calendarLink}" target="_blank" rel="noopener noreferrer" title="Add to Google Calendar" class="text-gray-400 hover:text-blue-500">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd" />
                                            </svg>
                                        </a>
                                    </div>
                                </div>
                                ${dishHtml}
                            </div>
                        </div>`;
                        
                        column.innerHTML = headerHtml + dailyDishesHtml;
                        menuContainer.appendChild(column);
                    }
                } else {
                    // Desktop view: Show all days as before
                    const cafeteriaOrder = ["HUB 1", "HUB 2", "HUB 3", "Foodcore"];
                    const daysOrder = ["Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag", "Søndag"];
                    menuContainer.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6';
                    
                    for (const cafeteria of cafeteriaOrder) {
                        const cafeteriaMenu = menuData[cafeteria];
                        if (!cafeteriaMenu) continue;
                        const column = document.createElement('div');
                        column.className = 'bg-white rounded-xl shadow-md overflow-hidden flex flex-col';
                        let headerHtml = `<div class="p-4 bg-gray-100 border-b border-gray-200"><h2 class="text-xl font-bold text-center text-gray-700">${cafeteria}</h2></div>`;
                        let dailyDishesHtml = '<div class="p-5 flex-grow">';
                        for (const day of daysOrder) {
                            const isRecommended = recommendations[day] === cafeteria;
                            const dishEntry = cafeteriaMenu[day];
                            if (!dishEntry) continue;
                            const cardClasses = `p-4 rounded-lg border-2 day-dish ${isRecommended ? 'highlight-dish' : 'bg-white border-transparent'}`;
                            let dishHtml = '';
                            let fullDishDescription = '';
                            if (typeof dishEntry === 'string') {
                                dishHtml = `<p class="text-gray-600">${dishEntry}</p>`;
                                fullDishDescription = dishEntry;
                            } else {
                                dishHtml = '<div>';
                                let dishParts = [];
                                for (const subKitchen in dishEntry) {
                                    dishHtml += `<div class="mb-2 last:mb-0"><h4 class="font-medium text-gray-700">${subKitchen}</h4><p class="text-gray-600">${dishEntry[subKitchen]}</p></div>`;
                                    dishParts.push(`${subKitchen}: ${dishEntry[subKitchen]}`);
                                }
                                dishHtml += '</div>';
                                fullDishDescription = dishParts.join(' / ');
                            }
                            const calendarLink = generateCalendarLink(day, cafeteria, fullDishDescription);
                            dailyDishesHtml += `<div class="${cardClasses}"><div class="flex justify-between items-center mb-2"><h3 class="font-semibold text-gray-800">${day}</h3><div class="flex items-center space-x-2">${isRecommended ? '<span class="text-xs font-bold bg-emerald-500 text-white py-1 px-2 rounded-full shadow">EAT HERE</span>' : ''}<a href="${calendarLink}" target="_blank" rel="noopener noreferrer" title="Add to Google Calendar" class="text-gray-400 hover:text-blue-500"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd" /></svg></a></div></div>${dishHtml}</div>`;
                        }
                        dailyDishesHtml += '</div>';
                        column.innerHTML = headerHtml + dailyDishesHtml;
                        menuContainer.appendChild(column);
                    }
                }
            }
            
            async function fetchWebsiteContent() {
                const proxyUrl = 'https://corsproxy.io/?';
                const menuUrl = 'https://hubnordic.madkastel.dk/';
                const fullUrl = `${proxyUrl}${encodeURIComponent(menuUrl)}`;
                
                console.log('🌐 Fetching website content from:', fullUrl);
                console.log('🌐 Target URL:', menuUrl);
                
                try {
                    const response = await fetch(fullUrl);
                    console.log('🌐 Response status:', response.status, response.statusText);
                    if (!response.ok) throw new Error('Network response was not ok.');
                    const content = await response.text();
                    console.log('🌐 Content length:', content.length, 'characters');
                    return content;
                } catch (error) {
                    console.error("❌ Failed to fetch website content:", error);
                    displayError("Kunne ikke oprette forbindelse til Madkastel-webstedet. Det er muligvis midlertidigt nede.");
                    return null;
                }
            }

            async function setCurrentWeek() {
                const weekNumber = await menuDB.getCurrentWeekNumber();
                if (currentWeekNumberSpan) {
                    currentWeekNumberSpan.textContent = weekNumber;
                }
            }
            
            function setViewMode(mode) {
                currentViewMode = mode;
                
                // Update toggle button styles
                if (dayViewBtn && weekViewBtn) {
                    if (mode === 'day') {
                        dayViewBtn.className = 'px-3 py-1 rounded-md text-sm font-medium text-gray-700 view-toggle-active transition-all duration-200';
                        weekViewBtn.className = 'px-3 py-1 rounded-md text-sm font-medium text-gray-500 view-toggle-inactive transition-all duration-200';
                    } else {
                        dayViewBtn.className = 'px-3 py-1 rounded-md text-sm font-medium text-gray-500 view-toggle-inactive transition-all duration-200';
                        weekViewBtn.className = 'px-3 py-1 rounded-md text-sm font-medium text-gray-700 view-toggle-active transition-all duration-200';
                    }
                }
                
                // Re-render menu if we have data
                if (parsedMenuData && currentRecommendations) {
                    renderMenu(parsedMenuData, currentRecommendations);
                }
            }
            
            function initViewToggle() {
                // Set initial view mode (day by default)
                setViewMode('day');
                
                // Add event listeners
                if (dayViewBtn) {
                    dayViewBtn.addEventListener('click', () => setViewMode('day'));
                }
                if (weekViewBtn) {
                    weekViewBtn.addEventListener('click', () => setViewMode('week'));
                }
            }

            // --- Event Listeners ---
            async function showPreferenceSuggestionPopup(daysWithNoMatch, menuData) {
                console.log('🔍 Suggestion popup triggered for days:', daysWithNoMatch);
                console.log('🔍 Menu data available:', Object.keys(menuData));
                
                const dishesForSuggestion = [];
                daysWithNoMatch.forEach(day => {
                    console.log(`🔍 Processing day: ${day}`);
                    for (const cafeteria in menuData) {
                        const dish = menuData[cafeteria]?.[day];
                        console.log(`   ${cafeteria}:`, dish);
                        if (typeof dish === 'string') {
                            dishesForSuggestion.push(dish);
                        } else if (typeof dish === 'object' && dish !== null) {
                            for (const subKitchen in dish) {
                                dishesForSuggestion.push(dish[subKitchen]);
                            }
                        }
                    }
                });
                
                console.log('🔍 Dishes collected for suggestions:', dishesForSuggestion.length);

                if (dishesForSuggestion.length > 0) {
                    console.log('🔍 Getting keyword suggestions from Gemini...');
                    loadingText.textContent = "Finding new suggestions for you... This may take up to 1 minute";
                    loadingSpinner.classList.remove('hidden');
                    const suggestedKeywords = await getKeywordSuggestionsFromGemini(dishesForSuggestion, appToken);
                    loadingSpinner.classList.add('hidden');

                    console.log('🔍 Suggested keywords from Gemini:', suggestedKeywords);
                    const uniqueNewKeywords = [...new Set(suggestedKeywords)].filter(k => !keywords.includes(k));
                    console.log('🔍 Unique new keywords (not already in preferences):', uniqueNewKeywords);

                    if (uniqueNewKeywords.length > 0) {
                        console.log('💡 Showing suggestion modal with', uniqueNewKeywords.length, 'new keywords');
                        suggestionsContainer.innerHTML = uniqueNewKeywords.map(keyword => `
                            <label class="flex items-center space-x-2 p-2 rounded-lg hover:bg-gray-100 cursor-pointer border">
                                <input type="checkbox" value="${keyword}" class="suggestion-checkbox h-4 w-4 rounded border-gray-300 text-emerald-600 focus:ring-emerald-500">
                                <span class="text-gray-800 capitalize">${keyword}</span>
                            </label>
                        `).join('');
                        suggestionModal.classList.remove('hidden');
                        
                        // Trigger custom event to auto-expand filters
                        window.dispatchEvent(new CustomEvent('suggestionModalShown'));
                    } else {
                        console.log('⚠️ No new keywords suggested or all already in preferences');
                    }
                } else {
                    console.log('⚠️ No dishes found for suggestion analysis');
                }
            }

            processBtn.addEventListener('click', async () => {
                const apiCallCount = getApiCount();
                if (apiCallCount >= API_CALL_LIMIT) {
                    displayError("You have reached your daily limit of 4 recommendations.");
                    return;
                }

                menuContainer.classList.add('hidden');
                errorContainer.classList.add('hidden');
                loadingSpinner.classList.remove('hidden');

                const activeKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked')).map(cb => cb.value).join(', ');
                if (!activeKeywords) {
                    displayError("Please select at least one food preference.");
                    loadingSpinner.classList.add('hidden');
                    return;
                }

                const activeFavoriteKeywords = favorites.filter(k => activeKeywords.includes(k)).join(', ');

                try {
                    // First try to get menu from shared database
                    const weekNumber = await menuDB.getCurrentWeekNumber();
                    console.log('🔍 Process started - Week:', weekNumber);
                    console.log('🔍 Checking shared database for menu...');
                    parsedMenuData = await menuDB.getMenu(weekNumber);
                    console.log('🔍 Database result:', parsedMenuData ? 'Found shared menu' : 'No shared menu found');

                    if (!parsedMenuData) {
                        // No shared menu found, need to parse from website
                        loadingText.textContent = "No shared menu available - parsing menu from website... This may take up to 1 minute";
                        const siteHtml = await fetchWebsiteContent();
                        if (!siteHtml) {
                            loadingSpinner.classList.add('hidden');
                            return;
                        }
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(siteHtml, 'text/html');
                        const relevantHtml = doc.body.innerHTML;
                        parsedMenuData = await parseMenuWithGemini(relevantHtml, appToken);
                        
                        if (parsedMenuData) {
                            // Save to local database
                            console.log('💾 Saving menu for week', weekNumber, 'to local database...');
                            const saveResult = await menuDB.saveMenu(weekNumber, parsedMenuData);
                            if (saveResult) {
                                console.log('✅ Menu saved successfully for week', weekNumber);
                                // Clean up old menus (keep last 4 weeks)
                                await menuDB.clearOldMenus(4);
                            } else {
                                console.error('❌ Failed to save menu for week', weekNumber);
                            }
                            // Also save to legacy localStorage cache for compatibility
                            saveMenuToCache(parsedMenuData);
                        }
                    } else {
                        loadingText.textContent = "Using cached menu data... Getting recommendations";
                    }

                    loadingText.textContent = "Getting your recommendations (optimized)... This may take up to 30 seconds";
                    const recommendations = await getRecommendationsFromGemini(parsedMenuData, activeKeywords, activeFavoriteKeywords, appToken);
                    
                    // Process results (for both cached and fresh data)
                    if (parsedMenuData && recommendations) {
                        incrementApiCount();
                        currentRecommendations = recommendations; // Store for toggle functionality
                        renderMenu(parsedMenuData, recommendations);
                        
                        // Auto-hide filter preferences after successful menu display
                        autoCollapseFilters();

                        const daysWithNoMatch = Object.keys(recommendations).filter(day => recommendations[day] === 'Any');
                        console.log('🔍 Recommendation analysis:');
                        console.log('   All recommendations:', recommendations);
                        console.log('   Days with no match:', daysWithNoMatch);
                        console.log('   Days with matches:', Object.keys(recommendations).filter(day => recommendations[day] !== 'Any'));
                        
                        if (daysWithNoMatch.length > 0) {
                            console.log('💡 Showing suggestion popup for', daysWithNoMatch.length, 'days with no matches');
                            await showPreferenceSuggestionPopup(daysWithNoMatch, parsedMenuData);
                        } else {
                            console.log('✅ All days have matches - no suggestions needed');
                        }
                    }
                } catch (error) {
                     console.error("Error in process:", error);
                     displayError(error.message);
                } finally {
                    loadingSpinner.classList.add('hidden');
                }
            });

            addKeywordBtn.addEventListener('click', () => {
                const newKeyword = newKeywordInput.value.trim().toLowerCase();
                if (newKeyword && !keywords.includes(newKeyword)) {
                    keywords.push(newKeyword);
                    saveCookie('canteen_keywords', keywords, 365);
                    renderKeywords();
                    newKeywordInput.value = '';
                }
            });

            newKeywordInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addKeywordBtn.click();
                }
            });

            keywordsContainer.addEventListener('click', (e) => {
                const deleteBtn = e.target.closest('.delete-keyword-btn');
                if (deleteBtn) {
                    const keywordToDelete = deleteBtn.dataset.keyword;
                    keywords = keywords.filter(k => k !== keywordToDelete);
                    favorites = favorites.filter(k => k !== keywordToDelete);
                    saveCookie('canteen_keywords', keywords, 365);
                    saveCookie('canteen_favorite_keywords', favorites, 365);
                    renderKeywords();
                    return;
                }

                const favBtn = e.target.closest('.rocket-favorite-btn');
                if (favBtn) {
                    const kw = favBtn.dataset.keyword;
                    const isCurrentlyFavorite = favorites.includes(kw);
                    
                    // Both toggle on and toggle off use the same flying animation
                    if (isCurrentlyFavorite) {
                        // If unfavoriting, trigger the flying animation with unfavorite callback
                        animateRocket(favBtn, () => {
                            // This callback runs BEFORE rocket becomes visible - remove from favorites
                            favorites = favorites.filter(k => k !== kw);
                            favBtn.classList.remove('active');
                            
                            // Apply inactive class to rocket icon directly
                            const rocketIcon = favBtn.querySelector('.rocket-icon');
                            if (rocketIcon) {
                                rocketIcon.classList.remove('active');
                            }
                            
                            saveCookie('canteen_favorite_keywords', favorites, 365);
                        });
                    } else {
                        // If favoriting, trigger the flying animation with favorite callback
                        animateRocket(favBtn, () => {
                            // This callback runs BEFORE rocket becomes visible - apply active class
                            favorites.push(kw);
                            favBtn.classList.add('active');
                            
                            // Apply active class to rocket icon directly
                            const rocketIcon = favBtn.querySelector('.rocket-icon');
                            if (rocketIcon) {
                                rocketIcon.classList.add('active');
                            }
                            
                            // Simple smoke animation restart
                            const smokeEffect = favBtn.querySelector('.smoke-effect');
                            if (smokeEffect) {
                                smokeEffect.style.animation = 'none';
                                smokeEffect.offsetHeight;
                                smokeEffect.style.animation = null;
                            }
                            saveCookie('canteen_favorite_keywords', favorites, 365);
                        });
                    }
                }
            });

            closeModalBtn.addEventListener('click', () => {
                suggestionModal.classList.add('hidden');
            });

            addSuggestionsBtn.addEventListener('click', () => {
                const selectedSuggestions = document.querySelectorAll('.suggestion-checkbox:checked');
                const newKeywords = Array.from(selectedSuggestions).map(cb => cb.value);

                if (newKeywords.length > 0) {
                    const uniqueNewKeywords = newKeywords.filter(k => !keywords.includes(k));
                    if (uniqueNewKeywords.length > 0) {
                        keywords.push(...uniqueNewKeywords);
                        saveCookie('canteen_keywords', keywords, 365);
                        renderKeywords();
                    }
                }
                suggestionModal.classList.add('hidden');
            });
            
            // --- Initial Setup ---
            const savedKeywords = loadCookie('canteen_keywords');
            keywords = Array.isArray(savedKeywords) && savedKeywords.length > 0 ? savedKeywords : defaultKeywords;
            
            const savedFavorites = loadCookie('canteen_favorite_keywords');
            favorites = Array.isArray(savedFavorites) ? savedFavorites : [];
            
            renderKeywords();
            setCurrentWeek().catch(console.error);
            updateApiLimitText();
            
            // Set up auto-hide functionality
            addAutoHideListeners();
            
            // Initialize view toggle
            initViewToggle();
            
            // Auto-click the "Get Menu & Recommendations" button when page loads
            setTimeout(() => {
                processBtn.click();
            }, 1); // Minimal delay to ensure DOM is fully loaded
        });
    </script>
</body>
</html>

